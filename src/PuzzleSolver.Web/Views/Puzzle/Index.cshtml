@model PuzzleSolver.Web.Models.PuzzleViewModel

@{
    ViewData["Title"] = "Решение головоломки";
}

<div class="container mt-4">
    <h1>@ViewData["Title"]</h1>

    <form id="puzzleForm" class="mt-4" method="get">
        <div class="row">
            <div class="col-md-6">
                <div class="form-group mb-3">
                    <label asp-for="Width" class="control-label"></label>
                    <input name="Width" class="form-control" type="number" min="1" max="20" value="@Model.Width" />
                    <span asp-validation-for="Width" class="text-danger"></span>
                </div>
            </div>
            <div class="col-md-6">
                <div class="form-group mb-3">
                    <label asp-for="Height" class="control-label"></label>
                    <input name="Height" class="form-control" type="number" min="1" max="20" value="@Model.Height" />
                    <span asp-validation-for="Height" class="text-danger"></span>
                </div>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-header">
                <h5 class="card-title mb-0">Фигуры</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    @for (var i = 0; i < Model.Bricks.Count; i++)
                    {
                        <div class="col-md-3 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h6 class="card-title">@Model.Bricks[i].DisplayName</h6>
                                    <canvas class="brick-canvas" 
                                           data-shape="@Model.Bricks[i].Shape" 
                                           data-color="@Model.Bricks[i].GetColor()">
                                    </canvas>
                                    <div class="form-group">
                                        <label class="control-label">Количество</label>
                                        <input type="number" class="form-control" min="0" max="100" 
                                               name="Bricks[@i].Count" value="@Model.Bricks[i].Count" />
                                        <input type="hidden" name="Bricks[@i].Type" value="@Model.Bricks[i].Type" />
                                        <input type="hidden" name="Bricks[@i].DisplayName" value="@Model.Bricks[i].DisplayName" />
                                        <input type="hidden" name="Bricks[@i].Shape" value="@Model.Bricks[i].Shape" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>

        <div class="form-group">
            <button type="submit" class="btn btn-primary">Решить</button>
        </div>
    </form>

    <div id="status" class="alert mt-3" style="display: none;"></div>

    <div id="results" class="card mt-3" style="display: none;">
        <div class="card-header">
            <h5 class="card-title mb-0">Результат</h5>
        </div>
        <div class="card-body">
            <div class="row" id="resultsContainer"></div>
        </div>
    </div>
</div>

<style>
    .brick-shape {
        display: inline-block;
        background: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
    }
    .brick-line, .board-line {
        display: flex;
        margin-bottom: 2px;
    }
    .brick-line:last-child, .board-line:last-child {
        margin-bottom: 0;
    }
    .brick-cell, .board-cell {
        width: 20px;
        height: 20px;
        border: 1px solid #dee2e6;
        margin-right: 2px;
        background: white;
        position: relative;
    }
    .board-cell[style*="background-color"] {
        border: 2px solid #000;
    }
    .board-result {
        display: inline-block;
        background: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
    }
    .brick-canvas {
        width: 80px;
        height: 80px;
        margin-bottom: 10px;
        background: #f8f9fa;
        border-radius: 4px;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
    .result-canvas {
        max-width: 250px;
        max-height: 250px;
        width: 100%;
        margin: 10px auto;
        display: block;
        background: #f8f9fa;
        border-radius: 4px;
    }
</style>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
}

<script>
    function drawBrick(canvas, shape, color) {
        const ctx = canvas.getContext('2d');
        const lines = shape.split('\n');
        const maxWidth = Math.max(...lines.map(line => line.length));
        const maxHeight = lines.length;
        
        // Устанавливаем размер canvas в пикселях (для четкости)
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        // Вычисляем размер ячейки с учетом отступов
        const padding = 10;
        const availableWidth = canvas.width - (padding * 2);
        const availableHeight = canvas.height - (padding * 2);
        const cellSize = Math.min(
            Math.floor(availableWidth / maxWidth),
            Math.floor(availableHeight / maxHeight)
        );
        
        // Вычисляем отступы для центрирования
        const offsetX = (canvas.width - (cellSize * maxWidth)) / 2;
        const offsetY = (canvas.height - (cellSize * maxHeight)) / 2;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (let y = 0; y < maxHeight; y++) {
            for (let x = 0; x < maxWidth; x++) {
                if (lines[y][x] === '*') {
                    ctx.fillStyle = color;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    const px = offsetX + (x * cellSize);
                    const py = offsetY + (y * cellSize);
                    ctx.fillRect(px, py, cellSize, cellSize);
                    ctx.strokeRect(px, py, cellSize, cellSize);
                }
            }
        }
    }

    function drawBoard(canvas, board) {
        const ctx = canvas.getContext('2d');
        const width = board.Width;
        const height = board.Height;
        
        // Устанавливаем размер canvas в зависимости от размера контейнера
        const containerWidth = canvas.parentElement.offsetWidth;
        const maxSize = Math.min(250, containerWidth - 20); // Уменьшим максимальный размер
        
        // Вычисляем размеры с учетом пропорций доски
        let canvasWidth, canvasHeight;
        if (width > height) {
            canvasWidth = maxSize;
            canvasHeight = (maxSize * height) / width;
        } else {
            canvasHeight = maxSize;
            canvasWidth = (maxSize * width) / height;
        }
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        
        // Вычисляем размер ячейки
        const padding = 20;
        const availableWidth = canvas.width - (padding * 2);
        const availableHeight = canvas.height - (padding * 2);
        const cellSize = Math.min(
            Math.floor(availableWidth / width),
            Math.floor(availableHeight / height)
        );
        
        // Вычисляем отступы для центрирования
        const offsetX = Math.floor((canvas.width - (cellSize * width)) / 2);
        const offsetY = Math.floor((canvas.height - (cellSize * height)) / 2);
        
        // Очищаем canvas
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Рисуем внешнюю сетку
        ctx.strokeStyle = '#dee2e6';
        ctx.lineWidth = 1;
        
        // Рисуем горизонтальные линии
        for (let y = 0; y <= height; y++) {
            const py = offsetY + y * cellSize;
            ctx.beginPath();
            ctx.moveTo(offsetX, py);
            ctx.lineTo(offsetX + width * cellSize, py);
            ctx.stroke();
        }
        
        // Рисуем вертикальные линии
        for (let x = 0; x <= width; x++) {
            const px = offsetX + x * cellSize;
            ctx.beginPath();
            ctx.moveTo(px, offsetY);
            ctx.lineTo(px, offsetY + height * cellSize);
            ctx.stroke();
        }
        
        // Создаем карту ячеек для быстрого поиска
        const cellMap = {};
        if (Array.isArray(board.Cells)) {
            board.Cells.forEach(cell => {
                cellMap[`${cell.X},${cell.Y}`] = cell;
            });
        }
        
        // Функция проверки границы
        function shouldDrawBorder(x, y, dx, dy) {
            const cell = cellMap[`${x},${y}`];
            const neighbor = cellMap[`${x + dx},${y + dy}`];
            return !neighbor || cell.BrickId !== neighbor.BrickId;
        }
        
        // Рисуем фигуры
        if (Array.isArray(board.Cells)) {
            // Сначала рисуем заливку
            board.Cells.forEach(cell => {
                ctx.fillStyle = cell.Color;
                const px = offsetX + (cell.X * cellSize);
                const py = offsetY + (cell.Y * cellSize);
                ctx.fillRect(px, py, cellSize, cellSize);
            });
            
            // Затем рисуем границы
            board.Cells.forEach(cell => {
                const px = offsetX + (cell.X * cellSize);
                const py = offsetY + (cell.Y * cellSize);
                
                // Проверяем все четыре стороны
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Верхняя граница
                if (shouldDrawBorder(cell.X, cell.Y, 0, -1)) {
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + cellSize, py);
                    ctx.stroke();
                }
                
                // Правая граница
                if (shouldDrawBorder(cell.X, cell.Y, 1, 0)) {
                    ctx.moveTo(px + cellSize, py);
                    ctx.lineTo(px + cellSize, py + cellSize);
                    ctx.stroke();
                }
                
                // Нижняя граница
                if (shouldDrawBorder(cell.X, cell.Y, 0, 1)) {
                    ctx.moveTo(px, py + cellSize);
                    ctx.lineTo(px + cellSize, py + cellSize);
                    ctx.stroke();
                }
                
                // Левая граница
                if (shouldDrawBorder(cell.X, cell.Y, -1, 0)) {
                    ctx.moveTo(px, py);
                    ctx.lineTo(px, py + cellSize);
                    ctx.stroke();
                }
            });
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Отрисовка фигур
        document.querySelectorAll('.brick-canvas').forEach(canvas => {
            const shape = canvas.dataset.shape;
            const color = canvas.dataset.color;
            drawBrick(canvas, shape, color);
        });

               // Обработка формы
    document.getElementById('puzzleForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const formData = new FormData(this);
            const data = {
                Width: parseInt(formData.get('Width')),
                Height: parseInt(formData.get('Height')),
                Bricks: []
            };

            // Собираем данные о фигурах
            let brickIndex = 0;
            while (formData.has(`Bricks[${brickIndex}].Type`)) {
                data.Bricks.push({
                    Type: formData.get(`Bricks[${brickIndex}].Type`),
                    DisplayName: formData.get(`Bricks[${brickIndex}].DisplayName`),
                    Shape: formData.get(`Bricks[${brickIndex}].Shape`),
                    Count: parseInt(formData.get(`Bricks[${brickIndex}].Count`) || '0')
                });
                brickIndex++;
            }

            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');
            const resultsContainer = document.getElementById('resultsContainer');

            // Очищаем предыдущие результаты
            resultsContainer.innerHTML = '';
            statusDiv.style.display = 'none';
            resultsDiv.style.display = 'none';

            // Создаем EventSource для получения решений
            const params = new URLSearchParams();
            params.append('Width', data.Width);
            params.append('Height', data.Height);

            data.Bricks.forEach((brick, index) => {
                params.append(`Bricks[${index}].Type`, brick.Type);
                params.append(`Bricks[${index}].DisplayName`, brick.DisplayName);
                params.append(`Bricks[${index}].Shape`, brick.Shape);
                params.append(`Bricks[${index}].Count`, brick.Count);
            });

            const eventSource = new EventSource(`/Puzzle/SolveStream?${params.toString()}`);
            let solutionCount = 0;

            eventSource.onmessage = function(event) {
                const message = JSON.parse(event.data);

                switch (message.type) {
                    case 'solution':
                        // Создаем элементы для нового решения
                        const col = document.createElement('div');
                        col.className = 'col-md-4 mb-3';

                        const card = document.createElement('div');
                        card.className = 'card';

                        const cardBody = document.createElement('div');
                        cardBody.className = 'card-body';

                        const title = document.createElement('h6');
                        title.className = 'card-title';
                        title.textContent = `Решение ${++solutionCount}`;

                        const canvas = document.createElement('canvas');
                        canvas.className = 'result-canvas';

                        cardBody.appendChild(title);
                        cardBody.appendChild(canvas);
                        card.appendChild(cardBody);
                        col.appendChild(card);
                        resultsContainer.appendChild(col);

                        drawBoard(canvas, message.data);
                        resultsDiv.style.display = 'block';
                        break;

                    case 'error':
                        statusDiv.textContent = message.message;
                        statusDiv.className = 'alert alert-danger mt-3';
                        statusDiv.style.display = 'block';
                        eventSource.close();
                        break;

                    case 'complete':
                        statusDiv.textContent = message.message;
                        statusDiv.className = 'alert alert-success mt-3';
                        statusDiv.style.display = 'block';
                        eventSource.close();
                        break;
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                statusDiv.textContent = 'Произошла ошибка при получении решений';
                statusDiv.className = 'alert alert-danger mt-3';
                statusDiv.style.display = 'block';
                eventSource.close();
            };
        });
    });
</script> 